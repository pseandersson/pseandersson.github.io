<!DOCTYPE html>
<html>

<head>
  <title>Chinese Checker</title>
  <style type="text/css">
    .gamesetup {
      display: flex;
      flex-direction: column;
      position: absolute;
      z-index: 1;
      top: 5vh;
      left: 5vw;
      padding: 5vh 5vw;
      width: 80vw;
      height: 80vh;
      background: white;
      border: 1px gray solid;
      border-radius: 5vmin;
      box-shadow: 0px 0px 5vmin 5vmin #00000080 ;
      font-size: 5vmin;
      font-family: sans-serif;
      justify-content: center;
      gap: 1vh;
      color: black;
    }

    select, button {
      font-size: 5vmin;
    }

    .hide {
      display: none;
    }
    html {
      height: 100%;
    }

    body {
      background: linear-gradient(#000033, #000033, #036);
      margin: 0;
      padding: 2vmin;
      width: 100%;
      height: 100%;
      color: whitesmoke;
      display: flex;
      flex-direction: column;
      justify-content: center;
      font-size: 5vmin;
    }

    #board {
      background: transparent;
      display: flex;
      width: 95vmin;
      height: 95vmin;
      padding: calc(2vmin - 2px);
      border: 2px #ffffffcc solid;
      border-radius: 10%;
      flex-direction: column;
      margin: 2vmin 0px;
    }

    #share {
      display: flex;
      flex-direction: row;
      width: 100%;
      justify-content: center;
      gap: 1vmin;
    }

    #share > input {
      flex-grow: 1;
      height: 100%;
    }

    .row {
      display: flex;
      flex-direction: row;
      width: 100%;
      gap: calc(2*5vmin/13);
      height: max-content;
      justify-content: center;
    }

    .spot {
      display: inline-block;
      width: calc(90vmin / 14 - 1vh / 2 - 2px);
      height: calc(90vmin / 14 - 1vh / 2 - 2px);
      border-radius: 50%;
      border: 1px solid white;
      background: aqua;
    }

    .row:nth-child(1n+5) .spot:nth-child(1n + 10) {
      background: green;
    }

    .row:nth-child(1n+10) .spot:nth-child(1n + 10) {
      background: orange;
    }

    .row:nth-child(1n+5) .spot:nth-last-child(1n +10) {
      background: yellow;
    }

    .row:nth-child(1n+10) .spot:nth-last-child(1n +10) {
      background: violet;
    }

    .row:nth-child(1n+5) .spot {
      background: white;
    }

    .row:nth-child(1n+14) .spot {
      background: red;
    }

    .home {
      border-style: dotted;
    }

    .selected-ball {
      box-shadow: 0px 0px 1vmin 1vmin #00ff00cc inset;
    }

    .player0 {
      background: radial-gradient(circle at 10% 10%, #cff, #0ff, #066) !important;
    }

    .player1 {
      background: radial-gradient(circle at 10% 10%, #cfc, #080, #060) !important;
    }

    .player2 {
      background: radial-gradient(circle at 10% 10%, #fdc, #fc0, #630) !important;
    }

    .player3 {
      background: radial-gradient(circle at 10% 10%, #fcc, #f00, #600) !important;
    }

    .player4 {
      background: radial-gradient(circle at 10% 10%, #fcf, #f0f, #606) !important;
    }

    .player5 {
      background: radial-gradient(circle at 10% 10%, #ffc, #ff0, #660) !important;
    }

    .near {
      background: #80ff8080 !important;
    }

    .jump {
      background: #8080ff80 !important;
    }
  </style>
  <script type="text/javascript" src="pako.min.js"></script>
  <script>
    function isOccupied(node) {
      return [0, 1, 2, 3, 4, 5].some(v => node.node.classList.contains(`player${v}`))
    }

    function moveFrom(node, firstMove) {
      let result = {
        from: node,
        near: [],
        jump: []
      }
      for (var i = 0; i < node.neighbors.length; i++) {
        let ni = node.neighbors[i]
        let di = node.directions[i]

        if (isOccupied(ni)) {
          for (var j = 0; j < ni.neighbors.length; j++) {
            let nj = ni.neighbors[j]
            let dj = ni.directions[j]
            if ((di - dj) % 180 === 0 && !isOccupied(nj)) {
              result.jump.push(nj)
            }
          }
        } else if (firstMove) {
          result.near.push(ni)
        }
      }
      return result
    }

    function checkPlayer(state, node) {
      return node.node.classList.contains(`player${state.activePlayer}`)
    }

    function toggleHighlightMove(moves) {
      moves.from.node.classList.toggle("selected-ball")
      for (var i = 0; i < moves.near.length; i++) {
        moves.near[i].node.classList.toggle("near")
      }
      for (let i = 0; i < moves.jump.length; i++) {
        moves.jump[i].node.classList.toggle("jump")

      }
      // moves.jump.forEach(n => n.node.classList.toggle("jump"))
    }

    function clearHighlights() {
      let collection = document.getElementsByClassName("spot")
      for (var i = 0; i < collection.length; i++) {
        collection[i].classList.remove("near", "jump")
      }
      // nodes.forEach(n => n.nodes.classList.remove("jump", "near"))
    }

    function performMove(a, b) {
      for (var i = 0; i < 6; i++) {
        let tag = `player${i}`
        if (a.node.classList.contains(tag)) {
          a.node.classList.remove(tag)
          b.node.classList.add(tag)
          break
        }
      }
    }

    function beginMove(node, origin) {
      let firstMove = origin === undefined || node == origin
      let moves = moveFrom(node, firstMove)
      //debug.innerText += "sss " + moves.jump + " lll " + moves.near
      if (moves.near.length === 0 && moves.jump.length === 0) {
        return undefined
      }

      if (firstMove && !isOccupied(node)) {
        return undefined
      }

      toggleHighlightMove(moves)

      return function (n) {
        try {
          toggleHighlightMove(moves)
          if (n === undefined) {
            performMove(node, origin)
          } else if (moves.jump.indexOf(n) > -1) {
            performMove(node, n)
            return beginMove(n, (origin !== undefined) ? origin : node)
          } else if (moves.near.indexOf(n) > -1) {
            performMove((origin !== undefined) ? origin : node, n)
          } else if ( origin !== undefined && origin !== n) {
            if ( node !== n ) {
              debug.innerText += "[Move cancelled]"
              performMove(node, (origin !== undefined)? origin : node )
              return false
            }
          } else if ( node === n) {
            debug.innerText += "[Move cancelled]"
            return false
          }
        } catch (err) {
          debug.innerText += err.message
        }
        return undefined
      }
    }

    function encodeBoard(activePlayer, numberOfPlayers) {
      let collection = document.getElementsByClassName("spot")
      const state = new Uint8Array(8*Math.ceil(collection.length/8))
      const comp = new Uint8Array(Math.ceil(3*collection.length/8))
      
      for (var i = 0;i < collection.length; i++) {
        const p = collection[i].classList.value.split(" ").filter(v => v.substr(0,6)=="player").map(s=>new Number(s.substr(6)))
        var b = 0
        
        if (p.length == 1) {
          b = p[0] + 1
        }
        state[i] = b
      }
      state[collection.length] = numberOfPlayers - 1
      state[collection.length+1] = activePlayer

      for (var i = 0, j=0;i < state.length; i+=8, j+=3) {
        comp[j] = state[i] + (state[i+1] << 3) + (state[i+2] << 6)
        comp[j + 1] = (state[i+2] >> 2) + (state[i+3] << 1) + (state[i+4] << 4) + (state[i+5] << 7)
        comp[j + 2] = (state[i+5] >> 1) + (state[i+6] << 2) + (state[i+7] << 5)
      }
      return {
        compact: btoa(String.fromCharCode.apply(null, comp)),
        compressed: btoa(String.fromCharCode.apply(null, window.pako.deflate(comp))),
        board: state.slice(0,121),
        numberOfPlayers: state[121] + 1,
        activePlayer: state[122]
      }
    }

    function decodeBoard(data, isCompressed) {
      const s = atob(data)
      const comp = new Uint8Array(s.length)

      for (var i = 0;i < s.length; i++) {
        comp[i] = s.charCodeAt(i)
      }
      const raw = (isCompressed) ? window.pako.inflate(comp) : comp

      const size = Math.ceil(8/3*raw.length)
      const decomp = new Uint8Array(size)

      for (var i=0,j=0; i < raw.length; i+=3, j+=8) {
        decomp[j]   = raw[i] & 7
        decomp[j+1] = (raw[i] >> 3) & 7
        decomp[j+2] = ((raw[i] >> 6) & 7) + ((raw[i+1] & 1) << 3)
        decomp[j+3] = ((raw[i+1] >> 1) & 7)
        decomp[j+4] = ((raw[i+1] >> 4) & 7)
        decomp[j+5] = ((raw[i+1]) >> 7) + ((raw[i+2] & 3) << 1)
        decomp[j+6] = ((raw[i+2]) >> 2) & 7
        decomp[j+7] = (raw[i+2] >> 5)
      }

      return {
        compressed: data,
        board: decomp.slice(0,121),
        numberOfPlayers: decomp[121] + 1,
        activePlayer: decomp[122]
      }
    }

    function setupGame() {
      startgame.onclick = (ev) => {
        try {
          setupBoard(Number.parseInt(numOfPlayers.value), 0)
          gamesetup.classList.add("hide")
        } catch (err) {
          debug.innerText += err.message
        }
      }
    }

    function nextPlayer(state) {
      state.playerCounter = (state.playerCounter + state.playerStep) % 6
      return Math.round(state.playerCounter)
    }

    function setupBoard(numberOfPlayers, activePlayer) {
      const playerOrder = [0, 5, 1, 4, 2, 3]

      const rows = [1, 2, 3, 4, 13, 12, 11, 10, 9, 10, 11, 12, 13, 4, 3, 2, 1]
      rows.forEach(spots => {
        const row = document.createElement("div")

        row.classList.add("row")
        for (var i = 0; i < spots; i++) {
          const spot = document.createElement("div")
          spot.classList.add("spot")
          row.appendChild(spot)
        }
        document.getElementById("board").appendChild(row)
      })

      const centers = new Array();
      const state = {
        playerStep: 6 / numberOfPlayers,
        playerCounter: activePlayer * 6 / numberOfPlayers,
        activePlayer: activePlayer, 
        clickAction: undefined 
      }

      const playersInGame = []
      for (var i = 0; i < numberOfPlayers; i++) {
         playersInGame.push(state.activePlayer)
         state.activePlayer = nextPlayer(state)
      }

      debug.innerText += "{Players " + playersInGame + "}"
      whosTurn.innerHTML = `Player ${playersInGame.indexOf(state.activePlayer)+1}`

      let collection = document.getElementsByClassName("spot")
      for (var i = 0; i < collection.length; i++) {
        let spot = collection[i]
        let center = {
          node: spot,
          x: spot.offsetLeft + spot.clientWidth / 2,
          y: spot.offsetTop + spot.clientHeight / 2,
          neighbors: new Array(),
          directions: new Array()
        }
        spot.onclick = (ev) => {
          try {
            if (typeof state.clickAction === "function") {
              state.clickAction = state.clickAction(center)
              if (state.clickAction === undefined) {
                debug.innerText += "[Next Player]"
                state.activePlayer = nextPlayer(state)
                whosTurn.innerHTML = `Player ${playersInGame.indexOf(state.activePlayer) + 1}`

                const state_enc = encodeBoard(state.activePlayer, numberOfPlayers)
                debug.innerText += `<br/>[${JSON.stringify(state_enc)}] //${state_enc.compressed.length}/${state_enc.compact.length}`
                debug.innerText += `<br/>[${JSON.stringify(decodeBoard(state_enc.compressed, true))}]`
              }
            } else if (checkPlayer(state, center)) {
              state.clickAction = beginMove(center)
            }

          } catch (err) {
            debug.innerText += err.message
          }
        }

        centers.push(center)
      }

      let r2 = 1.1 * (Math.pow(centers[0].x - centers[1].x, 2) + Math.pow(centers[0].y - centers[1].y, 2))
      //debug.innerText += "Radius: " + r2 + " | "
      for (var i = 0; i < centers.length; i++) {
        let ci = centers[i]
        for (var j = i + 1; j < centers.length; j++) {
          let cj = centers[j]
          let dx = cj.x - ci.x
          let dy = cj.y - ci.y
          let cr2 = (dx * dx + dy * dy)
          var ang = (Math.round(Math.atan2(dy, dx) * 180 / Math.PI) + 180) % 360
          ang = Math.round(ang / 60.0) * 60

          if (cr2 <= r2) {
            ci.neighbors.push(cj)
            ci.directions.push((ang + 180) % 360)
            cj.neighbors.push(ci)
            cj.directions.push(ang)
            //debug.innerText += `(ang ${ang} - ${(ang+180)%360})`
          }
          // debug.innerHTML +="<p>" + cr2 + " &lt; " + r2 + "</p>"
        }
      }

      let tips = [];
      for (var i = 0; i < centers.length; i++) {
        if (centers[i].neighbors.length === 2) {
          tips.push(centers[i])
        }
      }
      //debug.innerText += centers.length + " zzz "

      //debug.innerText += tips.map(v=> v.neighbors.length)

      for (var i = 0; i < tips.length; i++) {
        let tip = tips[i]
        let p = playerOrder[i]
        if (playersInGame.includes(p) === false) {
          continue
        }
        debug.innerText += `[player${p}]`
        tip.node.classList.add("home", `player${p}`)
        for (var j = 0; j < tip.neighbors.length; j++) {
          let tip2 = tip.neighbors[j]
          tip2.node.classList.add("home", `player${p}`)
          for (var k = 0; k < tip2.neighbors.length; k++) {
            let tip3 = tip2.neighbors[k]
            tip3.node.classList.add("home", `player${p}`)
            for (var l = 0; l < tip3.neighbors.length; l++) {
              tip3.neighbors[l].node.classList.add("home", `player${p}`)
            }
          }
        }
      }
    }
  </script>
</head>

<body>
  <h1>Chinese Checker <span id="whosTurn"></span></h1>
  <div id="gamesetup" class="gamesetup">
    <h1>Chinese Checker</h1>
    <p>Number of players</p>
    <select id="numOfPlayers">
      <option>2</option>
      <option>3</option>
      <option>4</option>
      <option>6</option>
    </select>
    <button id="startgame">Start</button>
  </div>
  <div id="board">
  </div>
  <div id="share">
    <input type="text" id="nextTurnUrl" value="http://assa/" readonly="true" />
    <button onclick="">Share</button>
  </div>
  <div id="debug" class="hide"></div>
  <script>
    try {
      setupGame()
    } catch (err) {
      document.getElementById("board").innerText = err.message
    }

  </script>
</body>

</html>